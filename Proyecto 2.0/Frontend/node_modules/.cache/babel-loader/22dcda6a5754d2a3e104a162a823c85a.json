{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function getIndexFromScroll(offset, positions) {\n  let sliceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let sliceEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : positions.length;\n\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? getIndexFromScroll(offset, positions, sliceStart, pivot) : getIndexFromScroll(offset, positions, pivot + 1, sliceEnd);\n}\nexport const getRenderableIndexes = _ref2 => {\n  let {\n    firstIndex,\n    lastIndex,\n    buffer,\n    minFirstIndex,\n    maxLastIndex\n  } = _ref2;\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nexport const useGridVirtualScroller = props => {\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerWidth, setContainerWidth] = React.useState(null);\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const firstRowIndex = Math.min(Math.max(0, apiRef.current.unstable_getLastMeasuredRowIndex()), getIndexFromScroll(top, rowsMeta.positions));\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getIndexFromScroll(top + rootRef.current.clientHeight, rowsMeta.positions);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = getIndexFromScroll(left, columnPositions);\n      lastColumnIndex = getIndexFromScroll(left + containerWidth, columnPositions);\n    }\n\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, rowsMeta.positions, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerWidth]);\n  React.useEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  React.useEffect(() => {\n    setContainerWidth(rootRef.current.clientWidth);\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(() => {\n    if (rootRef.current) {\n      setContainerWidth(rootRef.current.clientWidth);\n    }\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateRenderZonePosition(renderContext);\n    }\n  }, [renderContext, updateRenderZonePosition]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    setRenderContext(nextRenderContext);\n    prevRenderContext.current = nextRenderContext;\n  }, [setRenderContext, prevRenderContext]);\n  React.useEffect(() => {\n    if (containerWidth == null) {\n      return;\n    }\n\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\n\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n\n  const getRows = function () {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      renderContext\n    };\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerWidth,\n      ignoreAutoHeight\n    } = params;\n\n    if (!currentPage.range || !nextRenderContext || availableSpace == null) {\n      return null;\n    }\n\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = currentPage.rows[i];\n      renderedRows.push(row);\n      apiRef.current.unstable_calculateColSpan({\n        rowId: row.id,\n        minFirstColumn,\n        maxLastColumn\n      });\n    }\n\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _rootProps$components;\n\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) || ignoreAutoHeight ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else if (typeof rootProps.isRowSelectable === 'function') {\n        isSelected = rootProps.isRowSelectable(apiRef.current.getRowParams(id));\n      } else {\n        isSelected = true;\n      }\n\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: currentPage.range.firstRowIndex + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: function () {\n      let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      let {\n        style = {}\n      } = _ref,\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: function () {\n      let {\n        style = {}\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        style: _extends({}, style, contentSize)\n      };\n    },\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_excluded","React","ReactDOM","useForkRef","useGridApiContext","useGridRootProps","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridDensityRowHeightSelector","gridFocusCellSelector","gridTabIndexCellSelector","gridEditRowsStateSelector","useGridVisibleRows","useGridApiEventHandler","clamp","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","jsx","_jsx","getIndexFromScroll","offset","positions","sliceStart","sliceEnd","length","pivot","Math","floor","itemOffset","getRenderableIndexes","firstIndex","lastIndex","buffer","minFirstIndex","maxLastIndex","useGridVirtualScroller","props","apiRef","rootProps","visibleColumns","ref","disableVirtualization","onRenderZonePositioning","renderZoneMinColumnIndex","renderZoneMaxColumnIndex","getRowProps","columnPositions","columnsTotalWidth","rowHeight","cellFocus","cellTabIndex","rowsMeta","editRowsState","selectedRowsLookup","currentPage","renderZoneRef","useRef","rootRef","handleRef","renderContext","setRenderContext","useState","prevRenderContext","scrollPosition","top","left","containerWidth","setContainerWidth","prevTotalWidth","computeRenderContext","useCallback","firstRowIndex","lastRowIndex","rows","firstColumnIndex","lastColumnIndex","current","min","max","unstable_getLastMeasuredRowIndex","autoHeight","clientHeight","hasRowWithAutoHeight","firstRowToRender","lastRowToRender","rowBuffer","i","row","unstable_rowHasAutoHeight","id","useEffect","style","transform","scrollLeft","scrollTop","clientWidth","currentPageTotalHeight","handleResize","updateRenderZonePosition","nextRenderContext","initialFirstColumnToRender","columnBuffer","firstColumnToRender","visibleRows","state","useLayoutEffect","updateRenderContext","initialRenderContext","params","publishEvent","handleScroll","event","currentTarget","topRowsScrolledSincePreviousRender","abs","bottomRowsScrolledSincePreviousRender","topColumnsScrolledSincePreviousRender","bottomColumnsScrolledSincePreviousRender","shouldSetState","rowThreshold","columnThreshold","flushSync","handleWheel","handleTouchMove","getRows","minFirstColumn","maxLastColumn","availableSpace","ignoreAutoHeight","range","renderedRows","push","unstable_calculateColSpan","rowId","lastColumnToRender","renderedColumns","slice","_rootProps$components","model","lastVisibleRowIndex","baseRowHeight","unstable_getRowHeight","isSelected","isRowSelectable","getRowParams","components","Row","selected","index","isLastVisible","componentsProps","needsHorizontalScrollbar","contentSize","useMemo","height","shouldExtendContent","size","width","minHeight","rootStyle","overflowX","getRenderContext","unstable_getRenderContext","getRootProps","_ref","other","onScroll","onWheel","onTouchMove","getContentProps","getRenderZoneProps"],"sources":["/Users/jonavq/Downloads/Proyecto 2.0/Frontend/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function getIndexFromScroll(offset, positions, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const itemOffset = positions[pivot];\n  return offset <= itemOffset ? getIndexFromScroll(offset, positions, sliceStart, pivot) : getIndexFromScroll(offset, positions, pivot + 1, sliceEnd);\n}\nexport const getRenderableIndexes = ({\n  firstIndex,\n  lastIndex,\n  buffer,\n  minFirstIndex,\n  maxLastIndex\n}) => {\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nexport const useGridVirtualScroller = props => {\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const {\n    ref,\n    disableVirtualization,\n    onRenderZonePositioning,\n    renderZoneMinColumnIndex = 0,\n    renderZoneMaxColumnIndex = visibleColumns.length,\n    getRowProps\n  } = props;\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const renderZoneRef = React.useRef(null);\n  const rootRef = React.useRef(null);\n  const handleRef = useForkRef(ref, rootRef);\n  const [renderContext, setRenderContext] = React.useState(null);\n  const prevRenderContext = React.useRef(renderContext);\n  const scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  const [containerWidth, setContainerWidth] = React.useState(null);\n  const prevTotalWidth = React.useRef(columnsTotalWidth);\n  const computeRenderContext = React.useCallback(() => {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const firstRowIndex = Math.min(Math.max(0, apiRef.current.unstable_getLastMeasuredRowIndex()), getIndexFromScroll(top, rowsMeta.positions));\n    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getIndexFromScroll(top + rootRef.current.clientHeight, rowsMeta.positions);\n    let hasRowWithAutoHeight = false;\n    let firstColumnIndex = 0;\n    let lastColumnIndex = columnPositions.length;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: firstRowIndex,\n      lastIndex: lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n\n    for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      const row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = getIndexFromScroll(left, columnPositions);\n      lastColumnIndex = getIndexFromScroll(left + containerWidth, columnPositions);\n    }\n\n    return {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }, [disableVirtualization, rowsMeta.positions, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerWidth]);\n  React.useEffect(() => {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  React.useEffect(() => {\n    setContainerWidth(rootRef.current.clientWidth);\n  }, [rowsMeta.currentPageTotalHeight]);\n  const handleResize = React.useCallback(() => {\n    if (rootRef.current) {\n      setContainerWidth(rootRef.current.clientWidth);\n    }\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  const updateRenderZonePosition = React.useCallback(nextRenderContext => {\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rootProps.rowBuffer\n    });\n    const [initialFirstColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: renderZoneMinColumnIndex,\n      maxLastIndex: renderZoneMaxColumnIndex,\n      buffer: rootProps.columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;\n\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top,\n        left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  React.useLayoutEffect(() => {\n    if (renderContext) {\n      updateRenderZonePosition(renderContext);\n    }\n  }, [renderContext, updateRenderZonePosition]);\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    setRenderContext(nextRenderContext);\n    prevRenderContext.current = nextRenderContext;\n  }, [setRenderContext, prevRenderContext]);\n  React.useEffect(() => {\n    if (containerWidth == null) {\n      return;\n    }\n\n    const initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    const {\n      top,\n      left\n    } = scrollPosition.current;\n    const params = {\n      top,\n      left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\n\n  const handleScroll = event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n\n    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n\n  const handleWheel = event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n\n  const handleTouchMove = event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n\n  const getRows = (params = {\n    renderContext\n  }) => {\n    const {\n      renderContext: nextRenderContext,\n      minFirstColumn = renderZoneMinColumnIndex,\n      maxLastColumn = renderZoneMaxColumnIndex,\n      availableSpace = containerWidth,\n      ignoreAutoHeight\n    } = params;\n\n    if (!currentPage.range || !nextRenderContext || availableSpace == null) {\n      return null;\n    }\n\n    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstRowIndex,\n      lastIndex: nextRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: currentPage.rows.length,\n      buffer: rowBuffer\n    });\n    const renderedRows = [];\n\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = currentPage.rows[i];\n      renderedRows.push(row);\n      apiRef.current.unstable_calculateColSpan({\n        rowId: row.id,\n        minFirstColumn,\n        maxLastColumn\n      });\n    }\n\n    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({\n      firstIndex: nextRenderContext.firstColumnIndex,\n      lastIndex: nextRenderContext.lastColumnIndex,\n      minFirstIndex: minFirstColumn,\n      maxLastIndex: maxLastColumn,\n      buffer: columnBuffer\n    });\n    const firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef,\n      firstRowToRender,\n      lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    const rows = [];\n\n    for (let i = 0; i < renderedRows.length; i += 1) {\n      var _rootProps$components;\n\n      const {\n        id,\n        model\n      } = renderedRows[i];\n      const lastVisibleRowIndex = firstRowToRender + i === currentPage.rows.length - 1;\n      const baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) || ignoreAutoHeight ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else if (typeof rootProps.isRowSelectable === 'function') {\n        isSelected = rootProps.isRowSelectable(apiRef.current.getRowParams(id));\n      } else {\n        isSelected = true;\n      }\n\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: currentPage.range.firstRowIndex + firstRowToRender + i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    let shouldExtendContent = false;\n\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  const rootStyle = {};\n\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n\n  const getRenderContext = React.useCallback(() => {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext,\n    updateRenderZonePosition,\n    getRows,\n    getRootProps: (_ref = {}) => {\n      let {\n        style = {}\n      } = _ref,\n          other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: ({\n      style = {}\n    } = {}) => ({\n      style: _extends({}, style, contentSize)\n    }),\n    getRenderZoneProps: () => ({\n      ref: renderZoneRef\n    })\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}