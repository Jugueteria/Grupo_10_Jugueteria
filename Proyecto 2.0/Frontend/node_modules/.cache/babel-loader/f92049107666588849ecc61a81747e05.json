{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport const computeColumnTypes = function () {\n  let customColumnTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  const mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n\n  Object.entries(customColumnTypes).forEach(_ref => {\n    let [colType, colTypeDef] = _ref;\n\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref2) {\n  let {\n    initialFreeSpace,\n    totalFlexUnits,\n    flexColumns\n  } = _ref2;\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(_ref3 => {\n        let {\n          field\n        } = _ref3;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nlet columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [...cleanOrderedFields, ...columnsState.all.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(_ref4 => {\n      let [key, value] = _ref4;\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n\n  const newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport const getGridColDef = (columnTypes, type) => {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([`MUI: The column type \"${type}\" you are using is not supported.`, `Column type \"string\" is being used instead.`].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport const createColumnsState = _ref5 => {\n  let {\n    apiRef,\n    columnsToUpsert,\n    initialState,\n    columnTypes,\n    currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n    shouldRegenColumnVisibilityModelFromColumns,\n    keepOnlyColumnsToUpsert = false\n  } = _ref5;\n\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsStateWithoutColumnVisibilityModel;\n\n  if (isInsideStateInitializer) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    const currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: keepOnlyColumnsToUpsert ? [] : [...currentState.all],\n      lookup: _extends({}, currentState.lookup) // Will be cleaned later if keepOnlyColumnsToUpsert=true\n\n    };\n  }\n\n  let columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsStateWithoutColumnVisibilityModel.lookup[field];\n\n    if (existingState == null) {\n      // New Column\n      existingState = _extends({}, getGridColDef(columnTypes, newColumn.type), {\n        // TODO v6: Inline `getGridColDef`\n        field,\n        hasBeenResized: false\n      });\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    }\n\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsStateWithoutColumnVisibilityModel.lookup[field] = _extends({}, existingState, {\n      hide: newColumn.hide == null ? false : newColumn.hide\n    }, newColumn, {\n      hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsStateWithoutColumnVisibilityModel.lookup[field];\n      }\n    });\n  }\n\n  const columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  let columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    let hasModelChanged = false;\n\n    const newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(field => {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(field => {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n\n    columnsStateWithPreProcessing.all.forEach(field => {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n\n      let isVisibleBefore = currentColumnVisibilityModel[field];\n\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          const currentState = gridColumnsSelector(apiRef.current.state);\n          isVisibleBefore = !!currentState.lookup[field];\n        }\n      }\n\n      const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n\n  const columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender(_ref6) {\n  let {\n    firstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  } = _ref6;\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender(_ref7) {\n  let {\n    firstColumnIndex,\n    minColumnIndex,\n    columnBuffer,\n    firstRowToRender,\n    lastRowToRender,\n    apiRef,\n    visibleRows\n  } = _ref7;\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}","map":{"version":3,"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","getGridDefaultColumnTypes","gridColumnsSelector","gridColumnVisibilityModelSelector","clamp","COLUMNS_DIMENSION_PROPERTIES","computeColumnTypes","customColumnTypes","mergedColumnTypes","Object","entries","forEach","colType","colTypeDef","extendType","computeFlexColumnsWidth","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","length","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","keys","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","columnTypeWarnedOnce","applyInitialState","columnsState","initialState","orderedFields","dimensions","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","filter","newColumnLookup","newColDef","hasBeenResized","key","Infinity","newColumnsState","getGridColDef","columnTypes","type","process","env","NODE_ENV","console","warn","join","createColumnsState","apiRef","columnsToUpsert","currentColumnVisibilityModel","shouldRegenColumnVisibilityModelFromColumns","keepOnlyColumnsToUpsert","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","isInsideStateInitializer","current","state","columns","columnsStateWithoutColumnVisibilityModel","currentState","columnsToKeep","reduce","acc","columnsToUpsertLookup","existingState","undefined","hide","columnsLookupBeforePreProcessing","columnsStateWithPreProcessing","unstable_applyPipeProcessors","hasModelChanged","newColumnVisibilityModel","isVisibleBefore","isVisibleAfter","columnsStateWithPortableColumns","getRootDimensions","call","viewportInnerSize","mergeColumnsState","getFirstNonSpannedColumnToRender","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","getFirstColumnIndexToRender","firstColumnIndex","minColumnIndex","columnBuffer","initialFirstColumnToRender"],"sources":["/Users/jonavq/Downloads/Proyecto 2.0/Frontend/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport const computeColumnTypes = (customColumnTypes = {}) => {\n  const mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n\n  Object.entries(customColumnTypes).forEach(([colType, colTypeDef]) => {\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nlet columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [...cleanOrderedFields, ...columnsState.all.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n\n  const newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport const getGridColDef = (columnTypes, type) => {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([`MUI: The column type \"${type}\" you are using is not supported.`, `Column type \"string\" is being used instead.`].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnTypes,\n  currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  shouldRegenColumnVisibilityModelFromColumns,\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsStateWithoutColumnVisibilityModel;\n\n  if (isInsideStateInitializer) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    const currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: keepOnlyColumnsToUpsert ? [] : [...currentState.all],\n      lookup: _extends({}, currentState.lookup) // Will be cleaned later if keepOnlyColumnsToUpsert=true\n\n    };\n  }\n\n  let columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsStateWithoutColumnVisibilityModel.lookup[field];\n\n    if (existingState == null) {\n      // New Column\n      existingState = _extends({}, getGridColDef(columnTypes, newColumn.type), {\n        // TODO v6: Inline `getGridColDef`\n        field,\n        hasBeenResized: false\n      });\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    }\n\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsStateWithoutColumnVisibilityModel.lookup[field] = _extends({}, existingState, {\n      hide: newColumn.hide == null ? false : newColumn.hide\n    }, newColumn, {\n      hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsStateWithoutColumnVisibilityModel.lookup[field];\n      }\n    });\n  }\n\n  const columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  let columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    let hasModelChanged = false;\n\n    const newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(field => {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(field => {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n\n    columnsStateWithPreProcessing.all.forEach(field => {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n\n      let isVisibleBefore = currentColumnVisibilityModel[field];\n\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          const currentState = gridColumnsSelector(apiRef.current.state);\n          isVisibleBefore = !!currentState.lookup[field];\n        }\n      }\n\n      const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n\n  const columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender({\n  firstColumnIndex,\n  minColumnIndex,\n  columnBuffer,\n  firstRowToRender,\n  lastRowToRender,\n  apiRef,\n  visibleRows\n}) {\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}