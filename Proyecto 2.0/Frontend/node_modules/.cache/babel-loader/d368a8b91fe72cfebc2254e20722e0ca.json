{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nexport const GRID_DEFAULT_STRATEGY = 'none';\nexport const GRID_STRATEGIES_PROCESSORS = {\n  rowTreeCreation: 'rowTree',\n  filtering: 'rowTree',\n  sorting: 'rowTree'\n};\n/**\n * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)\n *\n * More information and detailed example in (TODO add link to technical doc when ready)\n *\n * Some plugins contains custom logic that must only be applied if the right strategy is active.\n * For instance, the row grouping plugin has a custom filtering algorithm.\n * This algorithm must be applied by the filtering plugin if the row grouping is the current way of grouping rows,\n * but not if the tree data is the current way of grouping rows.\n *\n * =====================================================================================================================\n *\n * The plugin containing the custom logic must use:\n *\n * - `useGridRegisterStrategyProcessor` to register their processor.\n *   When the processor of the active strategy changes, it will fire `\"activeStrategyProcessorChange\"` to re-apply the processor.\n *\n * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.\n *\n * =====================================================================================================================\n *\n * The plugin or component that needs to apply the custom logic of the current strategy must use:\n *\n * - `apiRef.current.unstable_applyStrategyProcessor` to run the processor of the active strategy for a given processor name.\n *\n * - the \"strategyAvailabilityChange\" event to update something when the active strategy changes.\n *    Warning: Be careful not to apply the processor several times.\n *    For instance \"rowsSet\" is fired by `useGridRows` whenever the active strategy changes.\n *    So listening to both would most likely run your logic twice.\n *\n * - The \"activeStrategyProcessorChange\" event to update something when the processor of the active strategy changes.\n *\n * =====================================================================================================================\n *\n * Each processor name is part of a strategy group which can only have one active strategy at the time.\n * For now, there is only one strategy group named `rowTree` which customize\n * - row tree creation algorithm.\n * - sorting algorithm.\n * - filtering algorithm.\n */\n\nexport const useGridStrategyProcessing = apiRef => {\n  const availableStrategies = React.useRef(new Map());\n  const strategiesCache = React.useRef({});\n  const registerStrategyProcessor = React.useCallback((strategyName, processorName, processor) => {\n    const cleanup = () => {\n      const _ref = strategiesCache.current[processorName],\n            otherProcessors = _objectWithoutPropertiesLoose(_ref, [strategyName].map(_toPropertyKey));\n\n      strategiesCache.current[processorName] = otherProcessors;\n    };\n\n    if (!strategiesCache.current[processorName]) {\n      strategiesCache.current[processorName] = {};\n    }\n\n    const groupPreProcessors = strategiesCache.current[processorName];\n    const previousProcessor = groupPreProcessors[strategyName];\n    groupPreProcessors[strategyName] = processor;\n\n    if (!previousProcessor || previousProcessor === processor) {\n      return cleanup;\n    }\n\n    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {\n      apiRef.current.publishEvent('activeStrategyProcessorChange', processorName);\n    }\n\n    return cleanup;\n  }, [apiRef]);\n  const applyStrategyProcessor = React.useCallback((processorName, params) => {\n    const activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);\n\n    if (activeStrategy == null) {\n      throw new Error(\"Can't apply a strategy processor before defining an active strategy\");\n    }\n\n    const groupCache = strategiesCache.current[processorName];\n\n    if (!groupCache || !groupCache[activeStrategy]) {\n      throw new Error(`No processor found for processor \"${processorName}\" on strategy \"${activeStrategy}\"`);\n    }\n\n    const processor = groupCache[activeStrategy];\n    return processor(params);\n  }, [apiRef]);\n  const getActiveStrategy = React.useCallback(strategyGroup => {\n    var _availableStrategyEnt;\n\n    const strategyEntries = Array.from(availableStrategies.current.entries());\n    const availableStrategyEntry = strategyEntries.find(_ref2 => {\n      let [, strategy] = _ref2;\n\n      if (strategy.group !== strategyGroup) {\n        return false;\n      }\n\n      return strategy.isAvailable();\n    });\n    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;\n  }, []);\n  const setStrategyAvailability = React.useCallback((strategyGroup, strategyName, isAvailable) => {\n    availableStrategies.current.set(strategyName, {\n      group: strategyGroup,\n      isAvailable\n    });\n    apiRef.current.publishEvent('strategyAvailabilityChange');\n  }, [apiRef]);\n  const strategyProcessingApi = {\n    unstable_registerStrategyProcessor: registerStrategyProcessor,\n    unstable_applyStrategyProcessor: applyStrategyProcessor,\n    unstable_getActiveStrategy: getActiveStrategy,\n    unstable_setStrategyAvailability: setStrategyAvailability\n  };\n  useGridApiMethod(apiRef, strategyProcessingApi, 'GridStrategyProcessing');\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_toPropertyKey","React","useGridApiMethod","GRID_DEFAULT_STRATEGY","GRID_STRATEGIES_PROCESSORS","rowTreeCreation","filtering","sorting","useGridStrategyProcessing","apiRef","availableStrategies","useRef","Map","strategiesCache","registerStrategyProcessor","useCallback","strategyName","processorName","processor","cleanup","_ref","current","otherProcessors","map","groupPreProcessors","previousProcessor","unstable_getActiveStrategy","publishEvent","applyStrategyProcessor","params","activeStrategy","Error","groupCache","getActiveStrategy","strategyGroup","_availableStrategyEnt","strategyEntries","Array","from","entries","availableStrategyEntry","find","strategy","group","isAvailable","setStrategyAvailability","set","strategyProcessingApi","unstable_registerStrategyProcessor","unstable_applyStrategyProcessor","unstable_setStrategyAvailability"],"sources":["/Users/jonavq/Downloads/Proyecto 2.0/Frontend/node_modules/@mui/x-data-grid/hooks/core/strategyProcessing/useGridStrategyProcessing.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nexport const GRID_DEFAULT_STRATEGY = 'none';\nexport const GRID_STRATEGIES_PROCESSORS = {\n  rowTreeCreation: 'rowTree',\n  filtering: 'rowTree',\n  sorting: 'rowTree'\n};\n\n/**\n * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)\n *\n * More information and detailed example in (TODO add link to technical doc when ready)\n *\n * Some plugins contains custom logic that must only be applied if the right strategy is active.\n * For instance, the row grouping plugin has a custom filtering algorithm.\n * This algorithm must be applied by the filtering plugin if the row grouping is the current way of grouping rows,\n * but not if the tree data is the current way of grouping rows.\n *\n * =====================================================================================================================\n *\n * The plugin containing the custom logic must use:\n *\n * - `useGridRegisterStrategyProcessor` to register their processor.\n *   When the processor of the active strategy changes, it will fire `\"activeStrategyProcessorChange\"` to re-apply the processor.\n *\n * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.\n *\n * =====================================================================================================================\n *\n * The plugin or component that needs to apply the custom logic of the current strategy must use:\n *\n * - `apiRef.current.unstable_applyStrategyProcessor` to run the processor of the active strategy for a given processor name.\n *\n * - the \"strategyAvailabilityChange\" event to update something when the active strategy changes.\n *    Warning: Be careful not to apply the processor several times.\n *    For instance \"rowsSet\" is fired by `useGridRows` whenever the active strategy changes.\n *    So listening to both would most likely run your logic twice.\n *\n * - The \"activeStrategyProcessorChange\" event to update something when the processor of the active strategy changes.\n *\n * =====================================================================================================================\n *\n * Each processor name is part of a strategy group which can only have one active strategy at the time.\n * For now, there is only one strategy group named `rowTree` which customize\n * - row tree creation algorithm.\n * - sorting algorithm.\n * - filtering algorithm.\n */\nexport const useGridStrategyProcessing = apiRef => {\n  const availableStrategies = React.useRef(new Map());\n  const strategiesCache = React.useRef({});\n  const registerStrategyProcessor = React.useCallback((strategyName, processorName, processor) => {\n    const cleanup = () => {\n      const _ref = strategiesCache.current[processorName],\n            otherProcessors = _objectWithoutPropertiesLoose(_ref, [strategyName].map(_toPropertyKey));\n\n      strategiesCache.current[processorName] = otherProcessors;\n    };\n\n    if (!strategiesCache.current[processorName]) {\n      strategiesCache.current[processorName] = {};\n    }\n\n    const groupPreProcessors = strategiesCache.current[processorName];\n    const previousProcessor = groupPreProcessors[strategyName];\n    groupPreProcessors[strategyName] = processor;\n\n    if (!previousProcessor || previousProcessor === processor) {\n      return cleanup;\n    }\n\n    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {\n      apiRef.current.publishEvent('activeStrategyProcessorChange', processorName);\n    }\n\n    return cleanup;\n  }, [apiRef]);\n  const applyStrategyProcessor = React.useCallback((processorName, params) => {\n    const activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);\n\n    if (activeStrategy == null) {\n      throw new Error(\"Can't apply a strategy processor before defining an active strategy\");\n    }\n\n    const groupCache = strategiesCache.current[processorName];\n\n    if (!groupCache || !groupCache[activeStrategy]) {\n      throw new Error(`No processor found for processor \"${processorName}\" on strategy \"${activeStrategy}\"`);\n    }\n\n    const processor = groupCache[activeStrategy];\n    return processor(params);\n  }, [apiRef]);\n  const getActiveStrategy = React.useCallback(strategyGroup => {\n    var _availableStrategyEnt;\n\n    const strategyEntries = Array.from(availableStrategies.current.entries());\n    const availableStrategyEntry = strategyEntries.find(([, strategy]) => {\n      if (strategy.group !== strategyGroup) {\n        return false;\n      }\n\n      return strategy.isAvailable();\n    });\n    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;\n  }, []);\n  const setStrategyAvailability = React.useCallback((strategyGroup, strategyName, isAvailable) => {\n    availableStrategies.current.set(strategyName, {\n      group: strategyGroup,\n      isAvailable\n    });\n    apiRef.current.publishEvent('strategyAvailabilityChange');\n  }, [apiRef]);\n  const strategyProcessingApi = {\n    unstable_registerStrategyProcessor: registerStrategyProcessor,\n    unstable_applyStrategyProcessor: applyStrategyProcessor,\n    unstable_getActiveStrategy: getActiveStrategy,\n    unstable_setStrategyAvailability: setStrategyAvailability\n  };\n  useGridApiMethod(apiRef, strategyProcessingApi, 'GridStrategyProcessing');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}